# Шпаргалка: генерирование случайных чисел в современном C++ (`<random>`)

Коротко, ясно и по делу — чтобы быстро ориентироваться при разработке серьёзных инструментов.
---

## Что это и зачем
- `<random>` (C++11+) — современная библиотека для псевдо- и (частично) аппаратной случайности.  
- Используется для: симуляций, игр, тестов, генерации паролей/пин-кодов (с оговорками), статистики.  
- Для **криптографии** `<random>` сам по себе не даёт гарантии; нужны криптографически стойкие источники и библиотеки.

---

## Основные компоненты (концептуально)
1. **Источник энтропии / сид (seed)** — начальное значение, от которого зависит последовательность.     - `std::random_device rd;` — попытка получить «хороший» системный источник (на деле: `/dev/urandom`, WinAPI и т.п.).  
2. **Генератор (PRNG engine)** — производит поток псевдослучайных битов.  
   - Примеры: `std::mt19937` (32-bit), `std::mt19937_64` (64-bit), `std::minstd_rand0`, `std::ranlux48`.  
3. **Распределение (distribution)** — переводит биты генератора в числа в нужном диапазоне/распределении.  
   - `std::uniform_int_distribution<>` — равномерное целое.  
   - `std::uniform_real_distribution<>` — равномерное вещественное.  
   - `std::normal_distribution<>` — нормальное (Гаусса) и др.

---

## Рекомендации по выбору
- Для большинства задач (скорость + качество) → `std::mt19937` или `std::mt19937_64`.  
- Если нужна большая «периодичность» или 64-бит — возьми `mt19937_64`.  
- Для критически безопасных ключей — используй специально предназначенные API (OS crypto, OpenSSL, libsodium), а не `mt19937`.

---

## Как строится шаблон использования (шаги, без полного кода)
1. *Получить сид*: `std::random_device rd;`  
2. *Инициализировать генератор с сидом*: `std::mt19937 gen(rd());`  
3. *Создать распределение с границами*: `std::uniform_int_distribution<int> dist(min, max);`  
4. *Генерировать число*: `int x = dist(gen);`  
5. *Для N чисел* — вызвать `dist(gen)` в цикле.

> Замечание: `random_device` может быть медленным или псевдо-реализован на некоторых платформах; всё же он лучше, чем `time()` для сидов.

---

## Примеры разумных диапазонов
- Пин (4 цифры): `dist(0, 9999)` → форматируй ведущие нули отдельно.  
- Капча / уникальный id: `dist(100000, 999999)` (6 цифр).  
- Тестовые числа: `[1, 100]`, `[0, RAND_MAX]` и т.п.

---

## Безопасность и угрозы
- `mt19937` — детерминистичен: зная сид, можно восстановить всю последовательность.  
- Для задач безопасности (ключи, токены, важные пароли):  
  - Используй `std::random_device` как источник (если ОС гарантирует криптостойкость), или  
  - используй `CryptGenRandom` / `BCryptGenRandom` на Windows, `/dev/urandom` или libsodium/openssl на Unix.  
- Никогда не используйте `rand()`/`srand()` для криптографических целей.

---

## Частые ошибки и ловушки
- **Не задавать диапазон** для распределения — не получится; всегда указывай разумный `min/max`.  
- **Seed = time(0) без кастинга** — на MSVC выдаст предупреждение; использовать `static_cast<unsigned int>(time(0))`, но лучше — `random_device`.  
- **Создание генератора внутри цикла**: создавая `gen` внутри каждой итерации с `random_device`, можешь потерять производительность; создавай `gen` один раз и переиспользуй.  
- **Плохой источник сидов**: если `random_device` псевдо (в реализации), подумай о внешнем источнике энтропии.

---

## Короткая шпаргалка по типам/функциям
- `std::random_device rd;` — источник (может быть медленным/псевдо).  
- `std::mt19937 gen(rd());` — генератор (32-bit).  
- `std::mt19937_64 gen64(rd());` — 64-bit генератор.  
- `std::uniform_int_distribution<int> dist(a, b);` — равномерно целые в `[a, b]`.  
- `std::uniform_real_distribution<double> dist(0.0, 1.0);` — равномерно вещественные в `[0.0, 1.0]`.  
- Вызов: `auto val = dist(gen);`

---

## Паттерны использования (шаги + примеры сценариев)
### Генератор N случайных чисел 1–100
1. Создать `std::random_device rd;`
2. Создать `std::mt19937 gen(rd());`
3. Создать `std::uniform_int_distribution<int> dist(1, 100);`
4. В цикле `for i in 0..N-1` — `print(dist(gen))`

### Генератор пароля-цифр для PIN
1. Создать `dist(0, 9)` и вызывать 4 раза, собирая символы.  
2. Альтернатива: сгенерировать `dist(0, 9999)` и затем вывести с ведущими нулями.

### Если нужна криптографическая стойкость
1. Не полагайся на `mt19937`.  
2. Используй OS крипто API или libsodium: запроси заданное количество случайных байт и преобразуй в нужный формат.

---

## Быстрая проверка качества (практика)
- Для валидации генератора можно запускать простые статистические тесты (сумма, среднее, распределение по классам).  
- `mt19937` с `random_device` как сид — для большинства негосударственных задач достаточно.

---

## Короткий чек-лист перед использованием в проекте
- [ ] Определён ли требуемый уровень безопасности (игра/тест/ключи)?  
- [ ] Выбран подходящий генератор (`mt19937` / `mt19937_64` / crypto API)?  
- [ ] Распределение и диапазон логичны и заданы явно?  
- [ ] Генератор и распределение инициализируются **один раз**, а не в каждой итерации?  
- [ ] Нет использования `rand()`/`srand()` в новых модулях?  
- [ ] При необходимости — используем внешние крипто-библиотеки.

---

## Дальше — углубление (когда будешь готов)
- Изучить `std::random_device` поведение на целевых платформах (Windows vs Linux).  
- Разобраться с другими распределениями: `normal_distribution`, `bernoulli_distribution`, `poisson_distribution`.  
- Для криптографии — ознакомься с OpenSSL RAND_bytes или libsodium `randombytes_buf()`.
